<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kubernetes on apcj@f5 blog</title>
    <link>/categories/kubernetes/</link>
    <description>Recent content in kubernetes on apcj@f5 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetes | Ephemeral Kubernetes Lab with IaC and GitOps</title>
      <link>/posts/ephemeral-kubernetes-lab-with-iac-and-gitops/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/ephemeral-kubernetes-lab-with-iac-and-gitops/</guid>
      <description>I&amp;rsquo;ve been thinking of moving my Kubernetes lab into the cloud, but with cloud resource usage being scrutinized by the IT department, running them 24x7 the way I&amp;rsquo;m used to is a no-go. I need a setup that meets the following requirements:
 Simple to create and tear down Applications must be pre-deployed when the cluster is up, as close to &amp;ldquo;just the way I left it there last night&amp;rdquo; as possible cost $0 when the setup has been switched off  I eventually settled on the idea of an ephemeral Kubernetes lab environment using Infrastructure as Code (IaC) and GitOps practices, which I will cover in this post.</description>
      <content>&lt;p&gt;I&amp;rsquo;ve been thinking of moving my Kubernetes lab into the cloud, but with cloud resource usage being scrutinized by the IT department, running them 24x7 the way I&amp;rsquo;m used to is a no-go. I need a setup that meets the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simple to create and tear down&lt;/li&gt;
&lt;li&gt;Applications must be pre-deployed when the cluster is up, as close to &amp;ldquo;just the way I left it there last night&amp;rdquo; as possible&lt;/li&gt;
&lt;li&gt;cost $0 when the setup has been switched off&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I eventually settled on the idea of an ephemeral Kubernetes lab environment using &lt;a href=&#34;#infrastructure-as-code-using-terraform&#34;&gt;Infrastructure as Code (IaC)&lt;/a&gt; and &lt;a href=&#34;#k8s-resource-management-via-gitops-using-argo-cd&#34;&gt;GitOps&lt;/a&gt; practices, which I will cover in this post. You can follow along by cross referencing the code found here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops&#34;&gt;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;infrastructure-as-code-using-terraform&#34;&gt;Infrastructure as Code using Terraform&lt;/h1&gt;
&lt;p&gt;Starting with the Kubernetes cluster, using a managed Kubernetes offering makes sense for me as my current focus is on Kubernetes applications.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If cluster customization is of importance, one can deploy Kubernetes on the cloud computes using tools like &lt;a href=&#34;https://github.com/kubernetes/kops&#34;&gt;kops&lt;/a&gt; or &lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray&#34;&gt;kubespray&lt;/a&gt;, similarly adopting IaC practices detailed below.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I went with &lt;a href=&#34;https://aws.amazon.com/eks/&#34;&gt;EKS&lt;/a&gt; as I am more familiar with AWS. An EKS cluster (or any other managed Kubernetes offerings in the public cloud) has a lot of dependencies on other cloud resources, such as computes, gateways, security policies and more. Rather than figuring out &lt;em&gt;when&lt;/em&gt; to create &lt;em&gt;what&lt;/em&gt;, &lt;a href=&#34;https://www.terraform.io/&#34;&gt;Terraform&lt;/a&gt; can be used to define all the cloud resources needed for a functional EKS cluster in a declarative manner. In addition, Terraform modules such as &lt;a href=&#34;https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest&#34;&gt;vpc&lt;/a&gt; and &lt;a href=&#34;https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest&#34;&gt;eks&lt;/a&gt; can be used to further abstract away the web of dependencies. All it takes is a couple of Terraform modules and some data sources to create the cluster, as seen here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/leonseng/terraform-everything/blob/master/eks-gitops/eks.tf&#34;&gt;https://github.com/leonseng/terraform-everything/blob/master/eks-gitops/eks.tf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With the cluster sorted, I turn my attention to deploying Kubernetes resources/applications in the cluster.&lt;/p&gt;
&lt;h1 id=&#34;k8s-resource-management-via-gitops-using-argo-cd&#34;&gt;K8s resource management via GitOps using Argo CD&lt;/h1&gt;
&lt;p&gt;It&amp;rsquo;s instinctive to start running &lt;code&gt;kubectl&lt;/code&gt; commands to deploy Kubernetes resources that make up your application in the cluster, but keeping track of them gets harder overtime. If the cluster is to be rebuilt on a regular basis, we&amp;rsquo;d best hope we have a record of what&amp;rsquo;s deployed in it, and what better option than storing the Kubernetes manifests in a Git repository where the IaC definitions are also stored. With the desired state of applications in Git, the next step is ensuring the cluster state reflects the desired state. This is where GitOps comes in.&lt;/p&gt;
&lt;p&gt;GitOps can be briefly described as an automated workflow that ensures the state of the cluster and its applications matches the desired state from the source of truth, or Git repositories in the case. GitOps achieves this with one of the two patterns below:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Changes are &lt;strong&gt;pushed&lt;/strong&gt; to the cluster&lt;/p&gt;
&lt;p&gt;Continuous deployment workflow applies the resource manifests on our cluster whenever there are changes in the Git repository. This can be done using simple Bash scripts, or orchestration tools like Ansible. A problem arises when there are multiple deployment workflows targeting the same cluster. As each workflow may not have a complete view of the cluster, it could lead to an inconsistent state in the cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changes are &lt;strong&gt;pulled&lt;/strong&gt; into the cluster&lt;/p&gt;
&lt;p&gt;Officially the preferred pattern in &lt;a href=&#34;https://opengitops.dev/blog/1.0-announcement/&#34;&gt;OpenGitOps v1.0.0&lt;/a&gt; - an agent in the cluster continuously polls the desired state from a remote Git repository, and applies the changes in the cluster. &lt;a href=&#34;https://argo-cd.readthedocs.io/en/stable/%5D&#34;&gt;Argo CD&lt;/a&gt; and &lt;a href=&#34;https://fluxcd.io/docs/&#34;&gt;Flux&lt;/a&gt; are two popular GitOps tools that employs this pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For this article, I will be using Argo CD, mainly for its explicit support for the &lt;a href=&#34;#the-one-app-to-rule-them-all&#34;&gt;App of Apps pattern&lt;/a&gt; which I will cover in a section further down.&lt;/p&gt;
&lt;h2 id=&#34;argo-cd-applications&#34;&gt;Argo CD Applications&lt;/h2&gt;
&lt;p&gt;In Argo CD, a Kubernetes application are defined via an &lt;a href=&#34;https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#applications&#34;&gt;&lt;code&gt;Application&lt;/code&gt; custom resource (CR)&lt;/a&gt;. An &lt;code&gt;Application&lt;/code&gt; CR provides Argo CD with the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;source&lt;/strong&gt;: the Git repository, revision and path to where the collection of Kubernetes resource manifests are stored&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;destination&lt;/strong&gt;: the target cluster (Argo CD supports multi-cluster GitOps) and namespace to apply/deploy Kubernetes resource manifests in&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An &lt;code&gt;Application&lt;/code&gt; CR can be as simple as this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The diagram below shows how an application is deployed with Argo CD:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/argocd-basic.png&#34; alt=&#34;Basic Argo CD workflow&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User creates/modifies and uploads Kubernetes resource manifests (e.g. Deployment, ConfigMap, Service etc) for an application into a Git repository.&lt;/li&gt;
&lt;li&gt;(&lt;strong&gt;manual step in cluster&lt;/strong&gt;) User deploys an &lt;code&gt;Application&lt;/code&gt; CR.&lt;/li&gt;
&lt;li&gt;Argo CD inspects &lt;code&gt;Application&lt;/code&gt; CR to discover the Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD pulls the Kubernetes resource manifests from the Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD applies/deploys the Kubernetes resource manifests into the target cluster and namespace per the &lt;code&gt;Application&lt;/code&gt; CR.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And just like that, our application deployment has been turned into code. Pretty cool! But we can do better&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;the-one-app-to-rule-them-all&#34;&gt;The One App To Rule Them All&lt;/h2&gt;
&lt;p&gt;The previous workflow still involves a manual step on the cluster - creating the &lt;code&gt;Application&lt;/code&gt; CR in the cluster. If the user forgets or makes a mistake, the state of the cluster will not reflect the desired state defined in the Git repository. In order to deal with such scenarios, let&amp;rsquo;s turn to the &lt;a href=&#34;https://argo-cd.readthedocs.io/en/stable/operator-manual/cluster-bootstrapping/#app-of-apps-pattern&#34;&gt;App of Apps pattern&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Remember that an &lt;code&gt;Application&lt;/code&gt; CR just points the agent to where the Kubernetes resource manifests are, there&amp;rsquo;s no limitation on what kind of resources it supports. Naturally, this can be extended to other &lt;code&gt;Application&lt;/code&gt; CRs! Here&amp;rsquo;s how it works:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/argocd-app-of-apps.png&#34; alt=&#34;Argo CD app of apps workflow&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with the &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;red&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; flow that shows the bootstrapping:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User creates a bootstrap Git repository to store &lt;code&gt;Application&lt;/code&gt; CRs for the actual applications we want to deploy.&lt;/li&gt;
&lt;li&gt;User deploys a bootstrap &lt;code&gt;Application&lt;/code&gt; CR on the cluster.&lt;/li&gt;
&lt;li&gt;Argo CD inspects the bootstrap &lt;code&gt;Application&lt;/code&gt; CR to discover the bootstrap Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD agent starts monitoring the Git repository for new &lt;code&gt;Application&lt;/code&gt; CRs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once the cluster has been bootstrapped (which only has to be done once when the cluster is being set up), let&amp;rsquo;s go through the &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;green&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; flow to see how applications are deployed/modified:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User creates/modifies and uploads Kubernetes resource manifests (e.g. Deployment, ConfigMap, Service etc) for an application into an application Git repository.&lt;/li&gt;
&lt;li&gt;User creates/modifies and uploads an &lt;code&gt;Application&lt;/code&gt; CR for the above application into the bootstrap Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD discovers new &lt;code&gt;Application&lt;/code&gt; CR in the bootstrap Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD deploys the &lt;code&gt;Application&lt;/code&gt; CR in the cluster, and from it, discover the application Git repository.&lt;/li&gt;
&lt;li&gt;Argo CD pulls the Kubernetes resource manifests from the application Git repository&lt;/li&gt;
&lt;li&gt;Argo CD applies the Kubernetes resource manifests into the target cluster and namespace per the &lt;code&gt;Application&lt;/code&gt; CR.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using the App of Apps pattern means we only have to maintain the desired state of our applications through Git, and Argo CD would automatically apply the desired state in the cluster.&lt;/p&gt;
&lt;p&gt;Phew&amp;hellip; that was a lot to take in 😅. Hopefully we are now in the right head space to move on to the next section where we automate the bootstrapping via Terraform.&lt;/p&gt;
&lt;h2 id=&#34;terraforming-gitops&#34;&gt;Terraforming GitOps&lt;/h2&gt;
&lt;p&gt;To integrate this GitOps workflow and the App of Apps pattern with the &lt;a href=&#34;#infrastructure-as-code-with-terraform&#34;&gt;IaC&lt;/a&gt; definitions, we use Terraform to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install Argo CD in the cluster&lt;/p&gt;
&lt;p&gt;I found two Terraform providers which can manage Kubernetes resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/kubernetes/latest&#34;&gt;kubernetes&lt;/a&gt; - officially supported by HashiCorp, but requires Kubernetes resources to be defined in the Terraform&amp;rsquo;s syntax HCL instead of YAML. It also does not support defining a CRD and any corresponding CRs within the same Terraform project, as the CRD won&amp;rsquo;t exist when Terraform is processing the CRs in the planning stage.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/gavinbunney/kubectl/latest&#34;&gt;kubectl&lt;/a&gt; - allows you to work in YAML and supports overwriting namespaces in the manifest. However, when performing &lt;code&gt;terraform destroy&lt;/code&gt;, it does not seem to wait for resources to be fully deleted before marking them as destroyed (see &lt;a href=&#34;https://github.com/gavinbunney/terraform-provider-kubectl/issues/109&#34;&gt;issue&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Neither of them are perfect, but I&amp;rsquo;m inclined to use the &lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/kubernetes/latest&#34;&gt;kubernetes&lt;/a&gt; provider for the official support, and deviate when it doesn&amp;rsquo;t work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bootstrap the cluster with an &lt;code&gt;Application&lt;/code&gt; CR to utilize the App of Apps pattern.&lt;/p&gt;
&lt;p&gt;As explained earlier, this &lt;code&gt;Application&lt;/code&gt; CR (see &lt;a href=&#34;https://github.com/leonseng/terraform-everything/blob/master/eks-gitops/bootstrap-app.yaml.tpl&#34;&gt;manifest&lt;/a&gt;) is responsible for defining the deployment of all other applications that we actually want running in our cluster. It simply points to a repository that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops/demo/argocd-apps&#34;&gt;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops/demo/argocd-apps&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;where there are two applications to be deployed - &lt;a href=&#34;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops/demo/httpbin&#34;&gt;httpbin&lt;/a&gt; and &lt;a href=&#34;https://github.com/leonseng/terraform-everything/tree/master/eks-gitops/demo/nginx&#34;&gt;nginx&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The full Terraform file can be seen here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/leonseng/terraform-everything/blob/master/eks-gitops/argocd.tf&#34;&gt;https://github.com/leonseng/terraform-everything/blob/master/eks-gitops/argocd.tf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;finale&#34;&gt;Finale&lt;/h1&gt;
&lt;p&gt;With the Terraform files and application manifests in their respective Git repositories, we can kick off the deployment with the Terraform commands&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;terraform init
terraform apply -auto-approve
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And at the end of the day, shutting it down is as easy as running&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;terraform destroy -auto-approve
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is it perfect? No. I need to be conscious of storing my application manifests in Git, which will slow me down. And occasionally, the destroy process fails due to some orphaned cloud resources (work in progress). But what I have now is an on/off button for my Kubernetes lab in the cloud, which should keep the IT department of my back 😁.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Kubernetes | SQL Server on Kubernetes - Part 2</title>
      <link>/posts/kubernetes/sql-server-kubernetes-2/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/kubernetes/sql-server-kubernetes-2/</guid>
      <description>Intro So in my last post I showed how you could create databases on Kubernetes. There are many reasons to do this. Equally, there are reasons not to do this, but for highly distributed deployments it does make sense.
This post is going to focus on the storage components of running a database on Kubernetes.
Why do I need persistent storage Persistent storage as the name implies allows you to store your data between container restarts.</description>
      <content>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;So in my last &lt;a href=&#34;https://codecowboy.io/kubernetes/sql-server-kubernetes/&#34;&gt;post&lt;/a&gt; I showed how you could create databases on Kubernetes. There are many reasons to do this. Equally, there are reasons not to do this, but for highly distributed deployments it does make sense.&lt;/p&gt;
&lt;p&gt;This post is going to focus on the storage components of running a database on Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;why-do-i-need-persistent-storage&#34;&gt;Why do I need persistent storage&lt;/h2&gt;
&lt;p&gt;Persistent storage as the name implies allows you to store your data between container restarts. This is important where data is stored in a database. You actually want your data to be persisted.&lt;/p&gt;
&lt;h2 id=&#34;how-do-i-do-this-in-kubernetes&#34;&gt;How do I do this in kubernetes?&lt;/h2&gt;
&lt;p&gt;Kubernetes has two concepts that allow you to persist data that we are going to use. The first is a persistent volume claim, the second is a persistent volume mount&lt;/p&gt;
&lt;h2 id=&#34;persistent-volume-claim&#34;&gt;Persistent Volume Claim&lt;/h2&gt;
&lt;p&gt;In Kubernetes a persistent volume claim is a way of &amp;ldquo;grabbing some storage&amp;rdquo; if you&amp;rsquo;re a user. The Kubernetes documentation describes this much more eloquently as &amp;ldquo;a request for storage from a user&amp;rdquo; and &amp;ldquo;the persistent volume API abstracts the details of storage from the user&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;This is documented &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/persistent-volumes/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In order to create a persistent volume claim, you can use a manifest like the one below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;PersistentVolumeClaim&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-data&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;accessModes&lt;/span&gt;:
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;ReadWriteOnce&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;resources&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;requests&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;storage&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100Mi&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;volumeMode&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Filesystem&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will request 100M as a filesystem mount with a Read and Write access mode, within the namespace mssql.&lt;/p&gt;
&lt;p&gt;Once I have a claim, I can create a pod that utilises the claim, and mounts a filesystem.&lt;/p&gt;
&lt;h2 id=&#34;persistent-storage-volumes&#34;&gt;Persistent Storage Volumes&lt;/h2&gt;
&lt;p&gt;Pods can use a claim as a volume. In order to do this, the following is added to the Deployment definition.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;volumeMounts&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssqldb&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/var/opt/mssql&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;volumes&lt;/span&gt;:
      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssqldb&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;persistentVolumeClaim&lt;/span&gt;:
          &lt;span style=&#34;color:#f92672&#34;&gt;claimName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This mounts the volume by mapping to a claim name.&lt;/p&gt;
&lt;p&gt;Note that the claim name is the same as our claim name in our PersistentVolumeClaim definition above. This essentially makes the &amp;ldquo;raw disk&amp;rdquo; available to the pod.&lt;/p&gt;
&lt;p&gt;The volume mount, mounts the volume as a filesystem within the container or pod. The reason that I can do this is that the volume mode in my PersistentVolumeClaim is set to Filesystem. This allows the volume to be mounted as a filesystem within the container / pod.&lt;/p&gt;
&lt;p&gt;The full definition is below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;apps/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Deployment&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;selector&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;matchLabels&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;strategy&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Recreate&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;terminationGracePeriodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;fsGroup&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mcr.microsoft.com/mssql/rhel/server:2019-latest&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;containerPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1433&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-port&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;protocol&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;TCP&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;env&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;MSSQL_PID&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Developer&amp;#34;&lt;/span&gt;
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ACCEPT_EULA&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Y&amp;#34;&lt;/span&gt;
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;MSSQL_SA_PASSWORD&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;valueFrom&lt;/span&gt;:
            &lt;span style=&#34;color:#f92672&#34;&gt;secretKeyRef&lt;/span&gt;:
              &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
              &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;SA_PASSWORD&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;volumeMounts&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssqldb&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/var/opt/mssql&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;volumes&lt;/span&gt;:
      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssqldb&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;persistentVolumeClaim&lt;/span&gt;:
          &lt;span style=&#34;color:#f92672&#34;&gt;claimName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;inside-the-container&#34;&gt;Inside the container&lt;/h2&gt;
&lt;p&gt;Inside the container I see the following&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora mssql&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl exec -it mssql-a-59b4fbc56d-68rzj -n mssql /bin/bash&lt;/span&gt;

bash-4.4$
bash-4.4$ df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay          80G  4.3G   76G   6% /
tmpfs            64M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;   64M   0% /dev
tmpfs           7.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  7.9G   0% /sys/fs/cgroup
/dev/xvda1       80G  4.3G   76G   6% /etc/hosts
shm              64M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;   64M   0% /dev/shm

/dev/xvdca      976M  112M  849M  12% /var/opt/mssql

tmpfs           7.9G   12K  7.9G   1% /run/secrets/kubernetes.io/serviceaccount
tmpfs           7.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  7.9G   0% /proc/acpi
tmpfs           7.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  7.9G   0% /proc/scsi
tmpfs           7.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  7.9G   0% /sys/firmware

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can see that the /var/opt/mssql filesystem is a filesystem that I can put data into.
In my case, this is the default data directory for my SQL Server database.&lt;/p&gt;
&lt;h2 id=&#34;how-do-i-check-this&#34;&gt;How do I check this?&lt;/h2&gt;
&lt;p&gt;If you want to check a persistent volume claim use the following commands.
&lt;em&gt;kubectl get pvc&lt;/em&gt; will show the current persistent volume claims and their status.&lt;/p&gt;
&lt;p&gt;For each persistent volume, you should be able to see the mode, capacity, storageclass and so on.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora mssql&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get pvc -n mssql&lt;/span&gt;
NAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mssql-data   Bound    pvc-5cd23b78-9feb-4db0-b2b0-dca7f6b56371   1Gi        RWO            gp2            33h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Further information can be gained by using the describe key word.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora mssql&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl describe  pvc -n mssql&lt;/span&gt;
Name:          mssql-data
Namespace:     mssql
StorageClass:  gp2
Status:        Bound
Volume:        pvc-5cd23b78-9feb-4db0-b2b0-dca7f6b56371
Labels:        &amp;lt;none&amp;gt;
Annotations:   pv.kubernetes.io/bind-completed: yes
               pv.kubernetes.io/bound-by-controller: yes
               volume.beta.kubernetes.io/storage-provisioner: kubernetes.io/aws-ebs
               volume.kubernetes.io/selected-node: ip-192-168-44-199.ap-southeast-2.compute.internal
Finalizers:    &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;kubernetes.io/pvc-protection&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
Capacity:      1Gi
Access Modes:  RWO
VolumeMode:    Filesystem
Used By:       mssql-a-59b4fbc56d-68rzj
Events:        &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In order to see the actual volumes you can use the following commands.&lt;/p&gt;
&lt;p&gt;This shows the volume, it&amp;rsquo;s status and storage class, as well as the associated volume claim, including the namespace that the volume claim lives in.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora mssql&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get pv&lt;/span&gt;
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM              STORAGECLASS   REASON   AGE
pvc-5cd23b78-9feb-4db0-b2b0-dca7f6b56371   1Gi        RWO            Delete           Bound    mssql/mssql-data   gp2                     33h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Similarly, when I perform a describe against the volume, we can see that this is running in AWS, we can see the type of storage and so on.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora mssql&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl describe pv&lt;/span&gt;
Name:              pvc-5cd23b78-9feb-4db0-b2b0-dca7f6b56371
Labels:            failure-domain.beta.kubernetes.io/region&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ap-southeast-2
                   failure-domain.beta.kubernetes.io/zone&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ap-southeast-2c
Annotations:       kubernetes.io/createdby: aws-ebs-dynamic-provisioner
                   pv.kubernetes.io/bound-by-controller: yes
                   pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs
Finalizers:        &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;kubernetes.io/pv-protection&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
StorageClass:      gp2
Status:            Bound
Claim:             mssql/mssql-data
Reclaim Policy:    Delete
Access Modes:      RWO
VolumeMode:        Filesystem
Capacity:          1Gi
Node Affinity:
  Required Terms:
    Term 0:        failure-domain.beta.kubernetes.io/zone in &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ap-southeast-2c&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
                   failure-domain.beta.kubernetes.io/region in &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ap-southeast-2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
Message:
Source:
    Type:       AWSElasticBlockStore &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a Persistent Disk resource in AWS&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    VolumeID:   aws://ap-southeast-2c/vol-087cd704ef36ad587
    FSType:     ext4
    Partition:  &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    ReadOnly:   false
Events:         &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;what-if-the-pod-restarts&#34;&gt;What if the pod restarts?&lt;/h2&gt;
&lt;p&gt;If the pod restarts, the newly scheduled pod will use the existing PVC and your data will still be there!&lt;/p&gt;
&lt;p&gt;This may cause transaction problems in your database, but for the most part the data will still be there.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Persistent volumes are cool, and they make your life running databases, but really persisting any storage on Kubernetes easier.&lt;/p&gt;
&lt;p&gt;I hope you had fun reading, look out for more topics soon!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Kubernetes | SQL Server on Kubernetes - Part 1</title>
      <link>/posts/kubernetes/sql-server-kubernetes/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/kubernetes/sql-server-kubernetes/</guid>
      <description>Intro Recently, I&amp;rsquo;ve been working with a customer who wants to provide databases on their Kubernetes cluster. Ever since Microsoft&amp;rsquo;s SQL Server was released on Linux some years ago, I&amp;rsquo;ve been fascinated with it. I decided to give it a go recently on Kubernetes, and get it all working.
This is part one, where I deploy SQL server without persistent storage. In part two, I will discuss using persistent storage.</description>
      <content>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;Recently, I&amp;rsquo;ve been working with a customer who wants to provide databases on their Kubernetes cluster.
Ever since Microsoft&amp;rsquo;s SQL Server was released on Linux some years ago, I&amp;rsquo;ve been fascinated with it.
I decided to give it a go recently on Kubernetes, and get it all working.&lt;/p&gt;
&lt;p&gt;This is part one, where I deploy SQL server without persistent storage.
In part two, I will discuss using persistent storage.&lt;/p&gt;
&lt;h2 id=&#34;why-databases&#34;&gt;Why databases?&lt;/h2&gt;
&lt;p&gt;There is a lot of debate about whether or not you &lt;em&gt;should&lt;/em&gt; run databases on kubernetes or not. If you&amp;rsquo;re operating in a public cloud environment, this is much more clear cut to my mind than if you&amp;rsquo;re not. If you are, then it may be better to use a service from a cloud provider where infrastructure is taken care of for you. It&amp;rsquo;s just easier.&lt;/p&gt;
&lt;p&gt;If you are not operating in a public cloud environment, then running on kubernetes gives you the resilience and abstraction from infrastructure that is as close as you can get to running in a public cloud. This is very useful in disconnected environments and environments where you cannot access public cloud (yes they do exist).&lt;/p&gt;
&lt;p&gt;Suffice to say, there are reasons that you may want to do this.&lt;/p&gt;
&lt;h2 id=&#34;why-sql-server&#34;&gt;Why SQL server?&lt;/h2&gt;
&lt;p&gt;SQL server is ubiquitous. It is the database that a lot of applications use. As applications get either refactored or shifted to kubernetes, it is reasonable to assume that there will be instances where running a SQL server database on kubernetes is needed.&lt;/p&gt;
&lt;h2 id=&#34;secret&#34;&gt;Secret&lt;/h2&gt;
&lt;p&gt;In order to get the database up and running, you will need to have a secret.
This is the initial SA password that is used for the database.
The easiest way to do this is to create an opaque secret.&lt;/p&gt;
&lt;p&gt;The command below creates an opaque secret with a password that is complex enough to start the database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;kubectl create secret generic mssql --from-literal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;SA_PASSWORD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MyC0m9l&amp;amp;xP@ssw0rd&amp;#34;&lt;/span&gt; --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mssql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;manifests&#34;&gt;Manifests&lt;/h2&gt;
&lt;p&gt;The manifests for deploying SQL server are relatively simple.
The pages &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-overview?view=sql-server-ver15&#34;&gt;here&lt;/a&gt; give a really good overview of the general installation and command line options available for SQL Server on linux. These can be converted to manifest files.&lt;/p&gt;
&lt;h3 id=&#34;namespace&#34;&gt;Namespace&lt;/h3&gt;
&lt;p&gt;First we create a namespace. Technically, you don&amp;rsquo;t need to do this and can run everything in the default namespace, but for neatness sake, I always think it&amp;rsquo;s worth creating a separate namespace.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Namespace&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pods&#34;&gt;Pods&lt;/h3&gt;
&lt;p&gt;Create a deployment for SQL server. I am creating a deployment rather than a statefulset for demonstration purposes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;apps/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Deployment&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;selector&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;matchLabels&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;strategy&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Recreate&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;terminationGracePeriodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;fsGroup&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mcr.microsoft.com/mssql/rhel/server:2019-latest&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;containerPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1433&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-port&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;protocol&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;TCP&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;env&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;MSSQL_PID&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Developer&amp;#34;&lt;/span&gt;
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ACCEPT_EULA&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Y&amp;#34;&lt;/span&gt;
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;MSSQL_SA_PASSWORD&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;valueFrom&lt;/span&gt;:
            &lt;span style=&#34;color:#f92672&#34;&gt;secretKeyRef&lt;/span&gt;:
              &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
              &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;SA_PASSWORD&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;environment-variables&#34;&gt;Environment variables&lt;/h4&gt;
&lt;p&gt;The environment variables that can be used to configure MSSQL server are listed &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-configure-environment-variables?view=sql-server-ver15&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the manifest above, I am using three variables.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSSQL_PID: The SQL Server edition or product key. In my case, &amp;ldquo;developer edition&amp;rdquo;&lt;/li&gt;
&lt;li&gt;ACCEPT_EULA: Accept the End User License Agreement&lt;/li&gt;
&lt;li&gt;MSSQL_SA_PASSWORD: The SA password for the database. In my case, this refers to the secret that I created earlier&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;
&lt;p&gt;Create a service that can be used to expose the pods that we created above. The service is named &lt;strong&gt;mssql-a&lt;/strong&gt; purely because I may have more than one database that i want to expose.&lt;/p&gt;
&lt;p&gt;This service exposes the database pods on port 1433, the default SQL server port.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Service&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;selector&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mssql-a&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
    - &lt;span style=&#34;color:#f92672&#34;&gt;protocol&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;TCP&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1433&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;targetPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1433&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;persistent-storage&#34;&gt;Persistent Storage&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;ll cover this piece in a second blog post, because it deserves its own topic entirely.&lt;/p&gt;
&lt;p&gt;The database manifest works but will store data locally only. This means that it is only useful for development purposes. If the pod is restarted for any reason, data will be lost.&lt;/p&gt;
&lt;h2 id=&#34;client-side-tools&#34;&gt;Client side tools&lt;/h2&gt;
&lt;p&gt;Install client side tools to connect to the database.&lt;/p&gt;
&lt;p&gt;There is a really good document &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-red-hat?view=sql-server-ver15&#34;&gt;here&lt;/a&gt; that describes how to install the client side utilities in order to connect to your database.&lt;/p&gt;
&lt;p&gt;I use fedora, so am using the instructions for RHEL8 (close enough)&lt;/p&gt;
&lt;p&gt;Use curl to install the microsoft repository on your system.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;sudo curl -o /etc/yum.repos.d/msprod.repo https://packages.microsoft.com/config/rhel/8/prod.repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Install the client side tooling and the unix ODBC client&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;sudo yum install -y mssql-tools unixODBC-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Add the SQL tools to your default path and load the path into the current environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;export PATH=&amp;#34;$PATH:/opt/mssql-tools/bin&amp;#34;&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt; ~/.bash_profile
echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;export PATH=&amp;#34;$PATH:/opt/mssql-tools/bin&amp;#34;&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Test your database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;sqlcmd -S localhost -U SA -P &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;YourPassword&amp;gt;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;port-forward-from-local-machine-to-database&#34;&gt;Port forward from local machine to database&lt;/h2&gt;
&lt;p&gt;As I have not created any ingress for my database, the easiest way for me to get connectivity is to port forward directly to it.
I can use the command below to port forward from my local workstation to my database.&lt;/p&gt;
&lt;p&gt;First I need to get the pod name of my database in order to port forward to it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;kubectl get pods -n mssql

NAME                       READY   STATUS    RESTARTS   AGE
mssql-a-8469f884f7-rrbx9   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          18m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I can then use the port-forward command to forward a local port to the pod port so that I can perform some testing and check that my database actually works.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;kubectl port-forward mssql-a-&amp;lt;pod&amp;gt; 1433:1433 -n mssql --address 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;database-connect-and-test&#34;&gt;Database connect and test&lt;/h2&gt;
&lt;p&gt;Once everything has been created on the kubernetes side of the house, we can connect to the database and see that it is available.&lt;/p&gt;
&lt;p&gt;I can connect to my database using the password I set originally. As I have port forwarded to my cluster, no ingress is needed. This is useful for testing.&lt;/p&gt;
&lt;p&gt;I create a database named &lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# sqlcmd -S localhost -U SA -P &amp;#39;MyC0m9l&amp;amp;xP@ssw0rd&amp;#39;&lt;/span&gt;
1&amp;gt; create database foo
2&amp;gt; go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If I select the names of all databases from the sys.Database table, I can see that the last entry is my database &lt;strong&gt;foo&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; name &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; sys.Databases
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;
name
&lt;span style=&#34;color:#75715e&#34;&gt;--------------------------------------------------------------------------------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;master
tempdb
model
msdb
foo

(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;rows&lt;/span&gt; affected)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I can switch to the &lt;strong&gt;foo&lt;/strong&gt; database and being to use it.
I create a table and insert a single line of data into my newly created database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; use foo
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;
Changed &lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt; context &lt;span style=&#34;color:#66d9ef&#34;&gt;to&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;.

&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; bar (id INT, name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;))
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;

&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; bar &lt;span style=&#34;color:#66d9ef&#34;&gt;values&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;

(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;rows&lt;/span&gt; affected)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If I select all of the data from my table &lt;strong&gt;bar&lt;/strong&gt; I can see the single line of data that I inserted above.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; bar
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;
id          name
&lt;span style=&#34;color:#75715e&#34;&gt;----------- --------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I have a functional database that is running on kubernetes!&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Running databases on kubernetes isn&amp;rsquo;t that difficult. There are reasons that you want to do this.
The difficult part about this is the ephemeral nature of pods on kubernetes and how to handle persistent storage with databases.
This is the topic of my next post, where I will show how to use persistent storage to make your databases on kubernetes more robust.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Kubernetes | Small Containers for fun </title>
      <link>/posts/kubernetes/smallest-container-ever/</link>
      <pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/kubernetes/smallest-container-ever/</guid>
      <description>Intro I have a side hobby where I try to create minimal container images. There are a number of reasons for this, but the primary one is because I&amp;rsquo;m a complete geek.
Other reasons include:
 It&amp;rsquo;s a neatness thing There&amp;rsquo;s an engineering imperative in me to be minimalist I don&amp;rsquo;t like waste The process of creation helps me understand the technology a little better Smaller images are great for testing at scale  Why The why I do this is mainly because it&amp;rsquo;s a hobby, but in this case, I started the ultra minimal container image build because someone I work with wanted to build a container for testing Istio latency at scale.</description>
      <content>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;I have a side hobby where I try to create minimal container images.
There are a number of reasons for this, but the primary one is because I&amp;rsquo;m a complete geek.&lt;/p&gt;
&lt;p&gt;Other reasons include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s a neatness thing&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s an engineering imperative in me to be minimalist&lt;/li&gt;
&lt;li&gt;I don&amp;rsquo;t like waste&lt;/li&gt;
&lt;li&gt;The process of creation helps me understand the technology a little better&lt;/li&gt;
&lt;li&gt;Smaller images are great for testing at scale&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;
&lt;p&gt;The why I do this is mainly because it&amp;rsquo;s a hobby, but in this case, I started the ultra minimal container image build
because someone I work with wanted to build a container for testing Istio latency at scale. He needed a container image that was ultimately small, so that he could spin up in his words &amp;lsquo;about 10,000&amp;rsquo; at once. The other goal was to minimise any application response time so that he could test Istio rather than the application behind Istio.&lt;/p&gt;
&lt;h2 id=&#34;building-a-minimal-image&#34;&gt;Building a minimal image&lt;/h2&gt;
&lt;p&gt;Building a minimal image is easy, and I&amp;rsquo;ve spoken about it before at Container Camp, and you can see the &lt;a href=&#34;https://www.youtube.com/watch?v=SWwd4uTVeF0&#34;&gt;video&lt;/a&gt; if you like.&lt;/p&gt;
&lt;p&gt;What I have realised is that there are two parts to building a minimal image:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using SCRATCH and only including your application in your image.&lt;/li&gt;
&lt;li&gt;Statically linking your binary - but doing so in a super strict and optimised way.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When I spoke at Container Camp a few years ago, I only used default options during my compile. I have since realised that I can go even smaller by optimising my compiler options!&lt;/p&gt;
&lt;h2 id=&#34;the-code&#34;&gt;The Code&lt;/h2&gt;
&lt;p&gt;This is the easy part.&lt;/p&gt;
&lt;p&gt;I needed an &amp;ldquo;application&amp;rdquo; that didn&amp;rsquo;t introduce any latency at all so that my colleague could perform Istio testing. I decided to go as minimal as possible and create an &amp;ldquo;application&amp;rdquo; that actually doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;p&gt;In order for the application to work within a containerised environment, it needs to continue to run, and never exit. If the application ever exits, the container will stop running.&lt;/p&gt;
&lt;p&gt;C is my chosen language of choice today, and I created the following application.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) { 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pause();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This tiny little code block does a single thing - it pauses the thread until a signal is received.&lt;/p&gt;
&lt;p&gt;In container terms, this means the container will run, and will wait for a valid signal, and then honour that signal. This is the perfect behaviour for container testing. The &amp;ldquo;application&amp;rdquo; in the container doesn&amp;rsquo;t do anything, so doesn&amp;rsquo;t add any latency to the transaction, and is perfect for testing.&lt;/p&gt;
&lt;h2 id=&#34;the-compilation&#34;&gt;The compilation&lt;/h2&gt;
&lt;p&gt;In order to meet my goal of making a really small container image, I need to compile the code. I need to compile the code in such a way that the code does not require external libraries. That is, the code is &lt;strong&gt;statically linked&lt;/strong&gt;. The second thing to make the application smaller is to compile the code using compiler options that strip out everything that is extraneous.&lt;/p&gt;
&lt;h3 id=&#34;linking&#34;&gt;Linking&lt;/h3&gt;
&lt;p&gt;There are generally two types on linking when compiling code, and it&amp;rsquo;s relevant for containers.&lt;/p&gt;
&lt;h4 id=&#34;dynamic-linking&#34;&gt;Dynamic Linking&lt;/h4&gt;
&lt;p&gt;When using dynamic linking, shared libraries within the operatig system are used. This has a good side benefit of making the executable smaller (typically). The rationale behind dynamic linking is that when you are running multiple applications on a single operating system, it is possible for multiple applications to use common shared libraries. This makes each individual application smaller.o&lt;/p&gt;
&lt;p&gt;The code snippet below creates a dynamically linked binary from my C code above. I&amp;rsquo;ve named the application &amp;ldquo;pausle&amp;rdquo; because all it does is &amp;ldquo;pause&amp;rdquo;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# gcc pausle.c -o pausle-dynamic&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If I use the &lt;strong&gt;ldd&lt;/strong&gt; command to see the dynamically linked libraries as part of my binary, you can see that there are three shared libraries used by the &lt;strong&gt;pausle-dynamic&lt;/strong&gt; application.:1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ldd pausle-dynamic&lt;/span&gt;
        linux-vdso.so.1 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007ffc93da0000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
        libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt; /lib64/libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007f32a782c000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
        /lib64/ld-linux-x86-64.so.2 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007f32a7a06000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, we can see that the size of the dynamically linked binary is 25K.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ls -lh pausle-dynamic&lt;/span&gt;
-rwxr-xr-x. &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 25K Jul  &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; 21:48 pausle-dynamic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;One would imagine that this is a very small application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s dynamically linked - &lt;strong&gt;should&lt;/strong&gt; be smaller&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s not doing anything, and is minimal anyway&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;What if I were to tell you that we could reduce the size of this application by 60%?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;compiler-options&#34;&gt;Compiler Options&lt;/h3&gt;
&lt;p&gt;What I realised is that if I &lt;strong&gt;aggressively&lt;/strong&gt; tune my compiler options, I can go even smaller again.
Using the compiler options below I can compile my code to the smallest possible statically linked binary that I can.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;gcc  -Os -fdata-sections -ffunction-sections -fipa-pta  -Wl,--gc-sections -Wl,-O1 -Wl,--as-needed -Wl,--strip-all paus
le.c -o pausle-dynamic-aggressive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ls -lh pausle-dynamic-aggressive&lt;/span&gt;
-rwxr-xr-x. &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 15K Aug  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; 20:34 pausle-dynamic-aggressive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Just by using agressive compiler options, the size of the code is smaller again.&lt;/p&gt;
&lt;h4 id=&#34;static-linking&#34;&gt;Static Linking&lt;/h4&gt;
&lt;p&gt;Static linking is where I include all of the libraries for the executable &amp;ldquo;inside&amp;rdquo; the binary itself. This is useful when operating inside a container as it removes the need to have shared libraries (and hence an entire operating system). This in theory should make the entire container image smaller, even if the size of the binary is slightly larger.&lt;/p&gt;
&lt;p&gt;To statically link the binary, I pass the -static option to the compiler.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;gcc -Os -s -static -ffunction-sections -fipa-pta  -Wl,--gc-sections pausle.c -o pausle-static
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This creates a slightly larger binary size&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ls -lh pausle-static&lt;/span&gt;
-rwxr-xr-x. &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 708K Aug  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; 20:38 pausle-static
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;WOAH&lt;/strong&gt; 708K.&lt;/p&gt;
&lt;p&gt;If I look at the linking using ldd again, I get the following message.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ldd pausle-static&lt;/span&gt;
        not a dynamic executable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This means that all of my libraries are included in the binary itself.&lt;/p&gt;
&lt;h2 id=&#34;building-containers&#34;&gt;Building containers&lt;/h2&gt;
&lt;p&gt;In order to build containers, I&amp;rsquo;m going to use the dockerfile format, it&amp;rsquo;s simple and is mostly uderstood.&lt;/p&gt;
&lt;p&gt;I use the following file&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;FROM registry.fedoraproject.org/fedora-minimal

ADD pausle-dynamic /
CMD &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pausle-dynamic&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I&amp;rsquo;m using a minimal fedora image here to build out my container image.
I add my dynamically linked binary into my image as a layer.&lt;/p&gt;
&lt;p&gt;I can build this using the following command.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# podman build --tag=pausle-dynamic .&lt;/span&gt;
STEP 1: FROM registry.fedoraproject.org/fedora-minimal
Getting image source signatures
Copying blob 033c7516884e &lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
Copying config 241281a93a &lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
Writing manifest to image destination
Storing signatures
STEP 2: ADD pausle-dynamic /
--&amp;gt; 54ab00ee58c
STEP 3: CMD &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pausle-dynamic&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
STEP 4: COMMIT pausle-dynamic
--&amp;gt; 96800d278c6
96800d278c61d69101791d416fd139a3e70afff2033063354c08307fa2eb118c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This builds me a container that we can see below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# podman images&lt;/span&gt;
REPOSITORY                                   TAG           IMAGE ID      CREATED         SIZE
localhost/pausle-dynamic                     latest        96800d278c61  &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; seconds ago  &lt;span style=&#34;color:#ae81ff&#34;&gt;119&lt;/span&gt; MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This comes out to 119MB - remember that the original binary was only 25K in size!&lt;/p&gt;
&lt;h3 id=&#34;using-scratch&#34;&gt;Using Scratch&lt;/h3&gt;
&lt;p&gt;Using the SCRATCH keyword, I can create a container that only has the required binary inside it.
It&amp;rsquo;s still a container, but doesn&amp;rsquo;t have any of the ancilliary &amp;ldquo;operating system&amp;rdquo; requirements.
It doesn&amp;rsquo;t have shared libraries, nor does it have any operating system tooling that you may expect to find.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;FROM scratch

ADD pausle-static /
CMD &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pausle-static&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I need to add my statically compiled binary here because there are no shared libraries available for a dynamically linked library to use.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s build this out.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# podman build --tag=pausle-static .&lt;/span&gt;
STEP 1: FROM scratch
STEP 2: ADD pausle-static /
--&amp;gt; 87ee8170167
STEP 3: CMD &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pausle-static&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
STEP 4: COMMIT pausle-static
--&amp;gt; d6e9daeb1ce
d6e9daeb1ce4211e3f04dd535494a3e78228c3642d22d350d6e9d4f2241e5861
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If I check my container image sizes we see the following.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@fedora&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# podman images&lt;/span&gt;
REPOSITORY                                   TAG           IMAGE ID      CREATED        SIZE
localhost/pausle-static                      latest        d6e9daeb1ce4  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; seconds ago  &lt;span style=&#34;color:#ae81ff&#34;&gt;727&lt;/span&gt; kB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will notice that this container is only 727KB in size.
It doesn&amp;rsquo;t have anything inside it EXCEPT the binary or the application that I&amp;rsquo;m going to run.&lt;/p&gt;
&lt;p&gt;In this way, I can build very small and minimal container images.
Even though my initial binary size is larger when I statically compile, it much reduces the overall size of my container image.&lt;/p&gt;
&lt;h3 id=&#34;other-benefits&#34;&gt;Other Benefits&lt;/h3&gt;
&lt;p&gt;Other benefits are that only having a single binary inside your container reduces the attack surface that&amp;rsquo;s available from a security perspective. There are no dependencies that need to be individually lifecycle managed, and no real provenance in terms of ancialliary tooling inside the container.&lt;/p&gt;
&lt;p&gt;The boot time of my container is much reduced because it&amp;rsquo;s smaller - this is a good thing.&lt;/p&gt;
&lt;p&gt;Next up I&amp;rsquo;ll talk a little about telemetry and how this can be included in your application stacks while keeping a minimal container footprint.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
